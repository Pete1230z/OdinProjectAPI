CLASS TYPES (C#)

REGULAR CLASS
A standard class that can be instantiated and inherited.

- Can contain fields, properties, methods, constructors
- Can be inherited unless marked sealed

Example:
public class UserService
{
    public void Execute() { }
}


SEALED CLASS
A class that cannot be inherited.

- Prevents other classes from deriving from it
- Common for DTOs and configuration classes
- Can improve performance slightly

Example:
public sealed class OdinSettingsDTO
{
    public string? GraphQLEndPoint { get; set; }
}


ABSTRACT CLASS
A class that cannot be instantiated directly.

- Intended to be inherited
- Can contain abstract members (no implementation)
- Can contain concrete members

Example:
public abstract class BaseService
{
    public abstract void Run();
}


STATIC CLASS
A class that cannot be instantiated or inherited.

- Contains only static members
- Used for utility or helper functionality

Example:
public static class ConfigurationHelpers
{
    public static void Validate() { }
}


PARTIAL CLASS
A class whose definition is split across multiple files.

- All parts combined at compile time
- Common with code generation

Example:
public partial class UserModel
{
    public string Name { get; set; }
}


GENERIC CLASS
A class defined with type parameters.

- Allows reuse with different data types
- Enforced at compile time

Example:
public class Repository<T>
{
    public T Get() => default!;
}


RECORD CLASS
A reference type optimized for immutable data.

- Value-based equality
- Common for DTOs and data models

Example:
public record UserRecord(string Name, int Id);


NESTED CLASS
A class declared inside another class.

- Scope limited to containing class
- Used for logical grouping

Example:
public class Outer
{
    public class Inner { }
}

    INHERITANCE
    A relationship where one class derives from another class.

    - Used to extend or specialize behavior
    - Child class automatically has access to accessible members of the base class
    - Established at compile time
    - Expresses an “is-a” relationship

    Syntax:
    public class DerivedClass : BaseClass { }

    Example:
    public class BaseService
    {
        public void Log() { }
    }

    public class UserService : BaseService
    {
        public void Execute() { }
    }


    INSTANTIATION
    The act of creating a runtime instance of a class.

    - Allocates memory for the object
    - Calls the constructor
    - Happens at runtime
    - Produces an object that can be used

    Syntax:
    var obj = new ClassName();

    Example:
    var service = new UserService();

    PROPERTY
    A named member of a class that exposes a value through accessors.

    - Has a type
    - Has a name
    - Has one or more accessors (get, set)
    - Commonly used for configuration and data models

    Example:
    public string? ForceStructureAPI { get; set; }

    FIELD
    A variable declared directly inside a class.

    - Stores data directly
    - Typically private
    - Less flexible than properties
    - Has a type
    - Has a name

    Example:
    private string _baseUrl;

    METHOD
    A block of code inside a class that performs an action.

    - Contains executable logic
    - Can accept parameters
    - Can return a value or void

    Example:
    public void LoadConfiguration() { }

    CONSTRUCTOR
    A special method used to create and initialize an object.

    - Same name as the class
    - Runs when new is called
    - No return type

    Example:
    public OdinSettings() { }


OBJECT (INSTANCE)
A runtime instance of a class.

- Created using new
- Exists in memory at runtime

Example:
var settings = new OdinSettings();


TYPE
Defines what kind of data a variable, property, or parameter can hold.

- Determines valid operations
- Enforced at compile time

    REFERENCE TYPE
    - Stored on the heap
    - Passed by reference

    Examples:
    class
    string

    VALUE TYPE
    - Copied by value
    - Stored directly

    Examples:
    int
    bool
    struct

    NULLABLE
    Indicates a value may be null.

    - Used with reference types
    - Important for configuration binding

    Example:
    string?


NULL
Represents the absence of a value.

- Valid state unless explicitly prevented
- Must be checked before use

Example:
if (value == null)


ACCESS MODIFIERS
Control visibility of classes and members.

- public    → Accessible from anywhere
- private   → Accessible only within the containing class
- internal  → Accessible within the same assembly


NAMESPACE
A logical grouping of related classes.

- Prevents name collisions
- Organizes code

Example:
namespace OdinProjectAPI;


PROGRAM
The entry point of a .NET application.

- Execution starts here
- Typically located in Program.cs


CONFIGURATION
A system for supplying values to an application at runtime.

- External to compiled code
- Environment-specific

    CONFIGURATION BINDING
    Maps configuration values to C# objects by convention.

    - Property name ↔ configuration key
    - Class structure ↔ JSON structure


JSON
A text-based data format for structured data.

- Uses key–value pairs
- Human-readable

Example:
{
  "Odin": {
    "GraphQLEndPoint": "..."
  }
}


DTO (DATA TRANSFER OBJECT)
A class used only to carry data.

- Properties only
- No behavior
- Common for configuration and API responses

Example:
public class OdinSettingsDto
{
    public string? GraphQLEndPoint { get; set; }
    public string? OutputFolder { get; set; }
}
